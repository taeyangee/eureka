# Q
比较在意以下问题
- 数据结构：注册表， [registry类体系](pic/InstanceRegistry.uml)
- 流程：server启动时，连接集群，全量拉取注册信息
- 流程：server运行时，集群间，增量同步注册信息
- 流程：client启动时，注册实例
- 流程：client启动时，拉取注册信息
- 流程：client运行时，连接任一server，增量同步注册信息
- 流程：client运行时，连接任一server，续约（心跳）
- 流程：client正常关闭时，连接任一server，注销实例
- 流程：client异常停止时，server感知无心跳，踢掉实例

# 数据结构 - 注册表
#### 核心抽象：服务信息与注册表
- 服务信息：eureka的管理对象
- 服务信息的层级抽象：ek分三级对应用的runtime信息做管理，Applications/Application/InstanceInfo,关系如下图
![](pic/Applications%20与%20InstanceInfo.png)
- registry：ek最核心的数据结构，用于服务信息的管理，所有代码最终都是为了维护这个对象。内部使用的结构其实很简单:
`Map<InstanceInfo#appName, Map<InstanceInfo#instanceId, Lease<InstanceInfo>>>`
#### [registry类体系](pic/InstanceRegistry.uml)
- LookupService：提供各种姿势查询服务实例信息
- LeaseManager: 租约（心跳）管理器，4个接口简单明了：注册、续租、取消( 主动下线 )、过期( 过期下线 )
- InstanceRegistry：
    - 处理client的服务信息请求，由AbstractInstanceRegistry实现
    - PeerAwareInstanceRegistry：提供集群特性，集群间同步、更新，由PeerAwareInstanceRegistryImpl实现
    
# 注册流程 - client发起注册
client发起注册的时机， 有两个：
- InstanceInfo在client侧刚被创建时，在Eureka-Server不存在，要注册到server端。
- 每次client测InstanceInfo发生属性变化时，`isInstanceInfoDirty`属性为会标记为true，表示 InstanceInfo 在 Eureka-Client 和 Eureka-Server 数据不一致，需要注册。

启动时的注册流程
- client启动后，InstanceInfo是通过`后台线程定时注册`的， 并不是立即注册（所以服务启动，到注册上线是有空表的）
- client的instanceinfo更新工作是有`instanceInfoReplicator`完成的
- 入口：`DiscoveryClient#initScheduledTasksinstanceInfoReplicator`中instanceInfoReplicator相关
    - 对应时机一：instanceInfoReplicator#start，开启定时。相关参数`InstanceInfoReplicationIntervalSeconds`    
    - 对应时机二：statusChangeListener注册回调为instanceInfoReplicator#onDemandUpdate
    - 最终都调用`instanceInfoReplicator#run`
- instanceInfoReplicator#run
    - 检查本地instanceInfo 配置信息、租期配置信息 是否变更，有则标记为dirty
    - 若有dirty标记， `EurekaClient#register()`使用EurekaHttpClient（jerseyClient）像server端发起注册请求， http为`{server url}/apps/{app name}`
    - 充值dirty标记
    
# 注册流程 - server端接收注册请求
- 入口：ApplicationsResource#getApplicationResource -> ApplicationResource#addInstance -> PeerAwareInstanceRegistry#register
- PeerAwareInstanceRegistry#register
    - 获取client的租约有效期配置（可见租约是sever对client管理 比较关系的一个点）
    - super#register(InstanceInfo registrant, int leaseDuration, boolean isReplication)
        - 其中`registrant`就是client走http传递过来的待处理注册信息
        - 根据registrant构造新的租约
        - 租约写入注册表registry
        - TODO:还变更了InstanceStatus，看不懂，先放着
        - 租约入队recentlyChangedQueue
        - registrant对应的cache置位失效
    - 像集群节点同步client的注册动作`replicateToPeers(Action.Register...)`
- 注册表结构： ConcurrentHashMap<String, Map<String, Lease<InstanceInfo>>> registry
- 租约类：Lease

# 服务发现
Eureka-Client获取注册信息，分成`全量获取`和`增量获取`
- 全量获取的时机：client刚启动时 `or` 运行时增量获取报错（instanceInfo的hash机制）
- 增量获取的时机：client运行时，定期30min拉取

# 服务发现 - 全量获取 - client发起请求
#### 入口： DiscoveryClient构造函数中，直接获取
```java
public class DiscoveryClient implements EurekaClient {
  DiscoveryClient(ApplicationInfoManager applicationInfoManager, EurekaClientConfig config, AbstractDiscoveryClientOptionalArgs args,
                    Provider<BackupRegistry> backupRegistryProvider) {

        // 【3.2.5】初始化应用集合在本地的缓存
        localRegionApps.set(new Applications());
        
        // 入口1： 【3.2.12】从 Eureka-Server 拉取注册信息
        if (clientConfig.shouldFetchRegistry() && !fetchRegistry(false)) {
          fetchRegistryFromBackup();
        }    
        
        // 入口2:【3.2.14】初始化定时任务， 启用了cacheRefreshExecutor
        initScheduledTasks();
    }
}
```
- 拉取全量缓存：fetchRegistry#getAndStoreFullRegistry
- 对server发起http请求：eurekaTransport#EurekaHttpClient#getApplications , url = "{server}/apps"
- 回写本地缓存：localRegionApps，做了并发处理，防止更早请求、但迟到的apps回复写入本地
关键组件：
- Applications本地缓存：AtomicReference<Applications> localRegionApps

#### 入口2： CacheRefreshThread定时任务
```text
  scheduler.schedule(
                    new TimedSupervisorTask(
                            "cacheRefresh",
                            scheduler,
                            cacheRefreshExecutor,
                            registryFetchIntervalSeconds,
                            TimeUnit.SECONDS,
                            expBackOffBound,
                            new CacheRefreshThread() //简单调用
                    ),
                    registryFetchIntervalSeconds, TimeUnit.SECONDS);
```
- CacheRefreshThread#run：`registryFetchIntervalSeconds`默认30s,跑一次
- refreshRegistry#fetchRegistry(remoteRegionsModified，基本为false)：请求server获取注册信息（同上）
- 设置 注册信息的应用实例数
- 设置 最后获取注册信息时间

TODO:TimedSupervisorTask？

# 全量获取 - server接收请求
入口：ApplicationsResource#getContainers
- 做了metric收集：EurekaMonitors
- 根据请求生成Key
- 根绝key查找缓存：ResponseCache#getGZIP(cacheKey)

# 增量获取 - client发送请求
- CacheRefreshThread 定时任务启动
- fetchRegistry：判断本地已有注册信息，调用getAndUpdateDelta
- EurekaHttpClient#getDelta 想server发起请求，那到增量注册信息delta、全量注册表hashcode
    - 合并 server返回的增量注册表 和 本地缓存的注册表
    - 计算合并后注册表hashcode
- delta == null 则全量重拉
- 合并后注册表hashcode != server端全量信息hashcode 则全量重拉

# 增强获取 - server接收请求   
- jersey rest框架将请求路由到ApplicationsResource#getContainerDifferential
- 根据请求，构造CacheKey，形如 `Application/ALL_APPS_DELTA/JSON/V2/full`
- 走缓存 拉取增量注册信息 `responseCache.getGZIP(cacheKey)`
- responseCache内部，同处理全量请求类似，先走RO，再走RW，不同的是，根据cacheKey的不同， computeIfAbsent时调用了`registry#getApplicationDeltasFromMultipleRegions`
- registry#getApplicationDeltasFromMultipleRegions
    - for一下recentlyChangedQueue，构造了增量注册表
    - 全量注册信息的hashcode，也一起返回， 给client做diff校验
- 返回：增量注册表 + 全量注册表hashcode