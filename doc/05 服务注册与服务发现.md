# Q
比较在意以下问题
- 数据结构：注册表， [registry类体系](pic/InstanceRegistry.uml)
- 流程：server启动时，连接集群，全量拉取注册信息
- 流程：server运行时，集群间，增量同步注册信息
- 流程：client启动时，注册实例
- 流程：client启动时，拉取注册信息
- 流程：client运行时，连接任一server，增量同步注册信息
- 流程：client运行时，连接任一server，续约（心跳）
- 流程：client正常关闭时，连接任一server，注销实例
- 流程：client异常停止时，server感知无心跳，踢掉实例

# 数据结构 - 注册表
#### 核心抽象：服务信息与注册表
- 服务信息：eureka的管理对象
- 服务信息的层级抽象：ek分三级对应用的runtime信息做管理，Applications/Application/InstanceInfo
- registry：ek最核心的数据结构，用于服务信息的管理，所有代码最终都是为了维护这个对象。内部使用的结构其实很简单:
`Map<InstanceInfo#appName, Map<InstanceInfo#instanceId, Lease<InstanceInfo>>>`
#### [registry类体系](pic/InstanceRegistry.uml)
- LookupService：提供各种姿势查询服务实例信息
- LeaseManager: 租约（心跳）管理器，4个接口简单明了：注册、续租、取消( 主动下线 )、过期( 过期下线 )
- InstanceRegistry：
    - 处理client的服务信息请求，由AbstractInstanceRegistry实现
    - PeerAwareInstanceRegistry：提供集群特性，集群间同步、更新，由PeerAwareInstanceRegistryImpl实现
    
# 注册流程 - client发起注册
client发起注册的时机， 有两个：
- InstanceInfo在client侧刚被创建时，在Eureka-Server不存在，要注册到server端。
- 每次client测InstanceInfo发生属性变化时，`isInstanceInfoDirty`属性为会标记为true，表示 InstanceInfo 在 Eureka-Client 和 Eureka-Server 数据不一致，需要注册。

启动时的注册流程
- client启动后，InstanceInfo是通过`后台线程定时注册`的， 并不是立即注册（所以服务启动，到注册上线是有空表的）
- client的instanceinfo更新工作是有`instanceInfoReplicator`完成的
- 入口：`DiscoveryClient#initScheduledTasksinstanceInfoReplicator`中instanceInfoReplicator相关
    - 对应时机一：instanceInfoReplicator#start，开启定时。相关参数`InstanceInfoReplicationIntervalSeconds`    
    - 对应时机二：statusChangeListener注册回调为instanceInfoReplicator#onDemandUpdate
    - 最终都调用`instanceInfoReplicator#run`
- instanceInfoReplicator#run
    - 检查本地instanceInfo 配置信息、租期配置信息 是否变更，有则标记为dirty
    - 若有dirty标记， `EurekaClient#register()`使用EurekaHttpClient（jerseyClient）像server端发起注册请求， http为`{server url}/apps/{app name}`
    - 充值dirty标记
    
# 注册流程 - server端接收注册请求
- 入口：ApplicationsResource#getApplicationResource -> ApplicationResource#addInstance -> PeerAwareInstanceRegistry#register
- PeerAwareInstanceRegistry#register
    - 获取client的租约有效期配置（可见租约是sever对client管理 比较关系的一个点）
    - super#register(InstanceInfo registrant, int leaseDuration, boolean isReplication)
        - 其中`registrant`就是client走http传递过来的待处理注册信息
        - 根据registrant构造新的租约
        - 租约写入注册表registry
        - TODO:还变更了InstanceStatus，看不懂，先放着
        - 租约入队recentlyChangedQueue
        - registrant对应的cache置位失效
    - 像集群节点同步client的注册动作`replicateToPeers(Action.Register...)`
- 注册表结构： ConcurrentHashMap<String, Map<String, Lease<InstanceInfo>>> registry
- 租约类：Lease

   