#### server端对注册信息的二级缓存设计
![](pic/server的注册信息缓存.png)
三层缓存设计
- 应用实例注册、下线、过期时，只过期readWriteCacheMap
- readWriteCacheMap写入一段时间( 可配置 )后自动过期。
- 定时任务对比 readWriteCacheMap 和 readOnlyCacheMap 的缓存值，若不一致，以前者为主。通过这样的方式，实现了 readOnlyCacheMap 的定时过期。
Eureka选择了AP vs Zookeeper 选择了CP 。
- [为什么不应该使用ZooKeeper做服务发现](http://dockone.io/article/78)

缓存的读取流程
- 尝试读RO，没有命中则往下
- 尝试读RW，没有命中则往下
    - 使用Guava cache实现 
    - cache过期参数：ResponseCacheAutoExpirationInSeconds， 180s
- registry中获取，并缓存。
    - 最终调用registr#getApplicationsFromMultipleRegions
    - 就是遍历`ConcurrentHashMap<String, Map<String, Lease<InstanceInfo>>> registry`生成Applications
    - 设置了Applications的`AppsHashCode`,用于client、server的注册校验
```text
CacheBuilder.newBuilder().initialCapacity(1000)
                        .expireAfterWrite(serverConfig.getResponseCacheAutoExpirationInSeconds(), TimeUnit.SECONDS)
                        .removalListener(new RemovalListener<Key, Value>() {
                            @Override
                            public void onRemoval(RemovalNotification<Key, Value> notification) {
                                // TODO[0009]：RemoteRegionRegistry
                                Key removedKey = notification.getKey();
                                if (removedKey.hasRegions()) {
                                    Key cloneWithNoRegions = removedKey.cloneWithoutRegions();
                                    regionSpecificKeys.remove(cloneWithNoRegions, removedKey);
                                }
                            }
                        })
                        .build(new CacheLoader<Key, Value>() {
                            @Override
                            public Value load(Key key) throws Exception {
                                // // TODO[0009]：RemoteRegionRegistry
                                if (key.hasRegions()) {
                                    Key cloneWithNoRegions = key.cloneWithoutRegions();
                                    regionSpecificKeys.put(cloneWithNoRegions, key);
                                }
                                Value value = generatePayload(key);
                                return value;
                            }
                        });
```