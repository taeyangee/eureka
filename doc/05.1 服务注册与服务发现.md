# 服务发现
Eureka-Client获取注册信息，分成`全量获取`和`增量获取`
- 全量获取的时机：client刚启动时 `or` 运行时增量获取报错（instanceInfo的hash机制）
- 增量获取的时机：client运行时，定期30min拉取

# 全量获取 - client发起请求
#### 入口： DiscoveryClient构造函数中，直接获取
```java
public class DiscoveryClient implements EurekaClient {
  DiscoveryClient(ApplicationInfoManager applicationInfoManager, EurekaClientConfig config, AbstractDiscoveryClientOptionalArgs args,
                    Provider<BackupRegistry> backupRegistryProvider) {

        // 【3.2.5】初始化应用集合在本地的缓存
        localRegionApps.set(new Applications());
        
        // 入口1： 【3.2.12】从 Eureka-Server 拉取注册信息
        if (clientConfig.shouldFetchRegistry() && !fetchRegistry(false)) {
          fetchRegistryFromBackup();
        }    
        
        // 入口2:【3.2.14】初始化定时任务， 启用了cacheRefreshExecutor
        initScheduledTasks();
    }
}
```
- 拉取全量缓存：fetchRegistry#getAndStoreFullRegistry
- 对server发起http请求：eurekaTransport#EurekaHttpClient#getApplications , url = "{server}/apps"
- 回写本地缓存：localRegionApps，做了并发处理，防止更早请求、但迟到的apps回复写入本地
关键组件：
- Applications本地缓存：AtomicReference<Applications> localRegionApps

#### 入口2： CacheRefreshThread定时任务
```text
  scheduler.schedule(
                    new TimedSupervisorTask(
                            "cacheRefresh",
                            scheduler,
                            cacheRefreshExecutor,
                            registryFetchIntervalSeconds,
                            TimeUnit.SECONDS,
                            expBackOffBound,
                            new CacheRefreshThread() //简单调用
                    ),
                    registryFetchIntervalSeconds, TimeUnit.SECONDS);
```
- CacheRefreshThread#run：`registryFetchIntervalSeconds`默认30s,跑一次
- refreshRegistry#fetchRegistry(remoteRegionsModified，基本为false)：请求server获取注册信息（同上）
- 设置 注册信息的应用实例数
- 设置 最后获取注册信息时间

TODO:TimedSupervisorTask？

# 全量获取 - server接收请求
入口：ApplicationsResource#getContainers
- 做了metric收集：EurekaMonitors
- 根据请求生成Key
- 根绝key查找缓存：ResponseCache#getGZIP(cacheKey)

#### server端对注册信息的三级缓存设计
![](pic/server的注册信息缓存.png)
三层缓存设计
- 应用实例注册、下线、过期时，只过期readWriteCacheMap
- readWriteCacheMap写入一段时间( 可配置 )后自动过期。
- 定时任务对比 readWriteCacheMap 和 readOnlyCacheMap 的缓存值，若不一致，以前者为主。通过这样的方式，实现了 readOnlyCacheMap 的定时过期。
Eureka选择了AP vs Zookeeper 选择了CP 。
- [为什么不应该使用ZooKeeper做服务发现](http://dockone.io/article/78)

缓存的读取流程
- 尝试读RO，没有命中则往下
- 尝试读RW，没有命中则往下
    - 使用Guava cache实现 
    - cache过期参数：ResponseCacheAutoExpirationInSeconds， 180s
- registry中获取，并缓存。
    - 最终调用registr#getApplicationsFromMultipleRegions
    - 就是遍历`ConcurrentHashMap<String, Map<String, Lease<InstanceInfo>>> registry`生成Applications
    - 设置了Applications的`AppsHashCode`,用于client、server的注册校验
```text
CacheBuilder.newBuilder().initialCapacity(1000)
                        .expireAfterWrite(serverConfig.getResponseCacheAutoExpirationInSeconds(), TimeUnit.SECONDS)
                        .removalListener(new RemovalListener<Key, Value>() {
                            @Override
                            public void onRemoval(RemovalNotification<Key, Value> notification) {
                                // TODO[0009]：RemoteRegionRegistry
                                Key removedKey = notification.getKey();
                                if (removedKey.hasRegions()) {
                                    Key cloneWithNoRegions = removedKey.cloneWithoutRegions();
                                    regionSpecificKeys.remove(cloneWithNoRegions, removedKey);
                                }
                            }
                        })
                        .build(new CacheLoader<Key, Value>() {
                            @Override
                            public Value load(Key key) throws Exception {
                                // // TODO[0009]：RemoteRegionRegistry
                                if (key.hasRegions()) {
                                    Key cloneWithNoRegions = key.cloneWithoutRegions();
                                    regionSpecificKeys.put(cloneWithNoRegions, key);
                                }
                                Value value = generatePayload(key);
                                return value;
                            }
                        });
```

# 