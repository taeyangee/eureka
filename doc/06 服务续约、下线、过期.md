# 服务续约 - client发起请求
- 定时任务： 发送实例心跳 heartbeatTask
- 配置： renewalIntervalInSecs， 续约周期默认30s 
  - TODO:租约有效期？默认情况下，租约有效期为90秒，续租频率为30秒。两者比例为 1 : 3 ，保证在网络异常等情况下，有三次重试的机会。
- 流程：
  - 调用 HeartbeatThread#renew()
    - 调用 EurekaHttpClient#sendHeartBeat向server端发送请求， 形如 put {server url}/apps/{app name}/{appid}
    - 如果收到回复NOT_FOUND， 重新发起注册请求
  - 更新 最后成功发送心跳的时间 

# 服务续约 - server处理请求
- jersey框架路由到 InstanceResource#renewLease
- registry#renew
- 拿到目标实例的租约 renew一下， leaseToRenew#renew, 其实就是更新一下lastUpdateTimestamp

# 服务下线
![](pic/下线应用实例的过程.jpeg)
#### 服务下线 - client发起请求
- DiscoveryClient#shutdown （整个流程可以对比 client启动）
    - cancelScheduledTasks(); /* 取消 各种定时器*/
    - unregister(); /* 像server发送注销请求 */
    - eurekaTransport.shutdown(); /* 关闭通信组件 */
    - 取消metric监控
- DiscoveryClient#unregister
- EurekaHttpClient#cancel 发起http请求，类似`delete http:/server/apps/appname/实例id`

#### 服务下线 - server处理请求
- jersey框架路由到 InstanceResource#cancelLease
- registry#cancel#internalCancel
    - leaseToCancel.cancel(); /* 租约取消：就是标记一下evictionTimestamp */
    - 记录为最近变动实例  
    - 标记缓存失效 invalidateCache(appName, vip, svip);
    
# 服务过期
![](pic/Eureka-Server%20过期超时续租的租约.png)
- 场景：正常情况下，应用实例下线时候会主动向 Eureka-Server 发起下线请求。但实际情况下，应用实例可能异常崩溃，又或者是网络异常等原因，导致下线请求无法被成功提交。
#### 服务过期 - server定时处理
- 租约清理任务 EvictionTask
- 初始化：evictionIntervalTimerInMs ，清理租约过期任务执行频率， 默认60s。
- 任务运行： 
    - 获取补偿时间： 补偿的是租期有效值，由于JVM GC或时间偏移( clock skew ) 等原因，定时器执行实际比预期会略有延迟，不考虑就会错杀未过期的服务
    - 是否开启自我保护，开启则不运行过期任务（详见 自我保护机制）
    - 寻找符合过期条件的实例： 已经主动下线 || 当期时间 > （上次租约的更新时间 + 租约有效期 + 补偿时间）
    - 根据配置`renewalPercentThreshold`(默认0.85)， 计算 可过期实例的最大允许数量
    - 在符合过期条件的实例随机抽取n个实例进行下线操作， n=可过期实例的最大允许数量
    - internalCancel执行某个实例的下线，这个函数： 实例主动下线也会调用， 不重复看了
- 设计：自我保护机制
    - 设计目的：当Eureka Server节点在短时间内丢失过多客户端时（可能发生了网络分区故障），那么这个节点就会进入自我保护模式。一旦进入该模式，Eureka Server就会保护服务注册表中的信息，不再删除服务注册表中的数据（也就是不会注销任何微服务）。当网络故障恢复后，该Eureka Server节点会自动退出自我保护模式。    
    - 关键变量：每分钟可续租实例的期望值expectedNumberOfClientsSendingRenews、每分钟续租次数的最小期望值numberOfRenewsPerMinThreshold
        - 每分钟续租次数的最小期望值 = 每分钟可续租实例的期望值 * (60/30, 即实例续租频率 ) * 0.85 （即续租百分比，期望有85%的实例可以完成续租 ） 
    - 触发条件： `renewsLastMin#getCount> numberOfRenewsPerMinThreshold`
        - expectedNumberOfClientsSendingRenews 的变更时机
        - 初始化时， 配置expectedNumberOfClientsSendingRenews
        - 定时15min， 根据实际的实例数量，设置expectedNumberOfClientsSendingRenews     
        - 注销时，期望数量-1
        - 注册时， 期望实例数量 + 1
    - renewsLastMin的变更时机： renew方法被调用时，就+1， 每60s重置
- 设计：分批过期
    - bug: 租约过期时间比预期多了一个duration, 即 2*duration( ===> 180s)
    - 设计目的：过期这个操作相对“危险”, 尽量避免单个应用的所有实例被一次性全部过期
    - 相关配置：如果想关闭分批逐步过期，设置 renewalPercentThreshold = 0 。
    - 分批过期的效果如下：
```text
// 假设 20 个租约，其中有 10 个租约过期。

// 第一轮执行开始
int registrySize = 20;
int registrySizeThreshold = (int) (20 * 0.85) = 17;
int evictionLimit = 20 - 17 = 3;
int toEvict = Math.min(10, 3) = 3;
// 第一轮执行结束，剩余 17 个租约，其中有 7 个租约过期。

// 第二轮执行开始
int registrySize = 17;
int registrySizeThreshold = (int) (17 * 0.85) = 14;
int evictionLimit = 17 - 14 = 3;
int toEvict = Math.min(7, 3) = 3;
// 第二轮执行结束，剩余 14 个租约，其中有 4 个租约过期。

// 第三轮执行开始
int registrySize = 14;
int registrySizeThreshold = (int) (14 * 0.85) = 11;
int evictionLimit = 14 - 11 = 3;
int toEvict = Math.min(4, 3) = 3;
// 第三轮执行结束，剩余 11 个租约，其中有 1 个租约过期。

// 第四轮执行开始
int registrySize = 11;
int registrySizeThreshold = (int) (11 * 0.85) = 9;
int evictionLimit = 11 - 9 = 2;
int toEvict = Math.min(1, 2) = 1;
// 第四轮执行结束，剩余 10 个租约，其中有 0 个租约过期。结束。
```